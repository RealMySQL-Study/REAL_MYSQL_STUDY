파티션 기능은 테이블을 논리적으로는 하나지만 물리적으로는 여러개로 분리해서 관리할 수 있게해줌

주로 대용량 테이블을 여러 소규모 테이블로 분산하는 목적으로 사용

# 13.1.1 파티션을 사용하는 이유

**파티션이 필요한 경우**
+ 테이블이 너무 커서 인텍스의 크기가 물리적인 메모리보다 클 때
+ 데이터 특성상 주기적인 삭제 작업이 필요한 경우 등

## 13.1.1.1 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

INDEX는 SELECT 뿐만 아니라 UPDATE, DELETE 작업을 위해서도 필수적인데 인덱스가 커질수록 작업이 느려짐

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/48f90191-d5d0-486f-b8c0-97a96306f7ab)

파티션 했을 때와 안했을 때의 워킹 셋이 메모리를 어떻게 사용하는지 위 그림으로 볼 수 있음

파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게 해줌
> 워킹 셋(Working Set) : 활발하게 사용되는 데이터

## 13.1.1.2 데이터의 물리적인 저장소를 분리

데이터 파일이나 인덱스 파일이 파일 시스템에서 많은 공간을 차지하면 백업이나 관리 작업이 어려워짐

MySQL은 데이터나 인덱스를 파일 단위로 관리하기 때문에 치명적인 문제가 될 수 있음<br>
=> 파티션을 통해 파일 크기를 조절하거나 파티션별 파일들이 저장될 위치를 구분해 해결할 수 있음

## 13.1.1.3 이력 데이터의 효율적인 관리

이력 데이터(예.로그 데이터)같은 경우 특정 기간이 지나면 해당하는 데이터를 백업 후 삭제하는데

일반 테이블에서 백업과 삭제하는 작업은 고부하의 작업이지만

파티션 테이블로 관리하면 단순히 파티션을 추가하고 삭제하는 방식으로 빠르게 해결 가능.


<br>

# 13.1.2 MySQL 파티션의 내부 처리

```sql
-- 파티션의 적용된 테이블의 INSERT, UPDATE, SELECT 처리 예시
CREATE TABLE TB_ARTICLE(
	ARTICLE_ID INT NOT NULL,
    REG_DATE DATETIME NOT NULL,
    PRIMARY KEY (ARTICLE_ID, REG_DATE)
) partition by range(year(REG_DATE))(
	partition p2009 VALUES LESS THAN (2010),
    partition p2010 VALUES LESS THAN (2011),
    partition p2011 VALUES LESS THAN (2012),
    partition p9999 VALUES LESS THAN maxvalue
);
```

## 13.1.2.1 파티션 테이블의 레코드 INSERT

INSERT 실행 => 파티션 표현식 평가 => 레코드가 저장될 적절한 파티션 결정 => 이후 과정은 일반 테이블과 동일

## 13.1.2.2 파티션 테이블의 UPDATE

UPDATE 실행 시 대상 레코드가 어느 파티션에 있는지 찾아야함

이때 WHERE 절에 파티션 키가 조건으로 걸려있으면 빠르게 저장된 파티션을 찾을 수 있음

조건이 안 걸려있으면 모든 파티션을 다 뒤짐

+ 파티션 키 변경 시 : 기존 파티션에서 레코드 삭제 후 변경되는 파티션에 새 레코드 저장
+ 파티션 키 미변경 시 : 일반 테이블과 마찬가지로 수정만 함

## 13.1.2.3 파티션 테이블의 검색

파티션 테이블 검색 시 성능에 영향을 주는 조건
+ WHERE 조건으로 검색할 파티션을 결정할 수 있는가
+ WHERE 조건으로 INDEX를 잘 사용할 수 있는가

위의 2가지 조건의 조합으로 볼 수 있는 경우의 수를 확인해보자

+ 파티션 선택 가능 + 인덱스 사용<br>
  가장 효율적임. 필요한 파티션의 인덱스만 레인지 스캔
+ 파티션 선택 불가 + 인덱스 사용<br>
  모든 파티션 개수만큼 인덱스 레인지 스캔 수행<br>
  스캔한 결과를 병합해서 가져오는 것과 같음
+ 파티션 선택 가능 + 인덱스 불가<br>
  선택한 파티션만 풀스캔함. 파티션의 레코드가 많으면 느려짐
+ 파티션 선택 불가 + 인덱스 불가<br>
  모든 파티션을 풀스캔함

웬만하면 1, 2번으로 돌도록 짜자

2번도 파티션이 많으면 느려짐

## 13.1.2.4 파티션 테이블의 인덱스 스캔과 정렬

파티션 테이블의 인덱스는 파티션 단위로 생성되며 테이블 전체 단위의 인덱스는 지원하지 않음























