# 11.4 SELECT

INSERT 나 UPDATE 같은 작업보다 SELECT를 많이 쓰이고 빠르게 동작해야 하니 성능 위주로 보자

## 11.4.1 SELECT 절의 처리 순서

```SQL
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt
FROM salaries s
	INNER JOIN employees e ON e.emp_no = s.emp_no
WHERE s.emp_no in (100001, 100002)
GROUP BY s.emp_no
HAVING AVG(s.salary) > 1000
ORDER BY AVG(s.salary)
LIMIT 10;
```

쿼리에서 어느절이 먼저 실행될 지 예측하지 못하면 처리내용이나 처리결과를 예측할 수 없음

**테이블 드라이빙(WHERE, JOIN) => GROUP BY => DISTINCT => HAVING => ORDER BY => LIMIT**

ORDER BY나 GROUP BY 절이 있더라도 인덱스를 이용할 때는 그 단계가 불필요해서 생략

<br>

**예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우**

GROUP BY 없이 ORDER BY만 사용된 쿼리<br>
테이블 드라이빙 => ORDER BY => 드리븐 테이블 조인 => LIMIT

<br>

위에서 제시한 2가지의 순서를 벗어나려면 서브쿼리를 사용해야함

```SQL
SELECT EMP_NO, CNT
FROM (
	SELECT S.EMP_NO, COUNT(DISTINCT E.FIRST_NAME) AS CNT, MAX(S.SALARY) AS MAX_SALARY
    FROM SALARIES S
    INNER JOIN EMPLOYEES E ON E.EMP_NO = S.EMP_NO
    WHERE S.EMP_NO IN (100001, 100002)
    GROUP BY S.EMP_NO
    HAVING MAX(S.SALARY) > 1000
    LIMIT 10
) temp_view
ORDER  BY MAX_SALARY;
```

인라인 뷰를 사용하면 임시 테이블이 사용되기 때문에 주의해야함

> MySQL 8.0 부터는 FROM 절의 서브쿼리를 외부 쿼리와 병합해서 쿼리를 최적화 할 수도 있음<br>
> 이 경우 결국 조인으로 실행되는 형태가 되기 때문에 위에서 제시한 1, 2번째 중 하나의 순서로 실행됨


MySQL 8.0에 새로 도입된 WITH절(CTE, Common Table Expression)은 항상 먼저 실행되어 임시테이블로 저장됨

<br>

## 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스

### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙

**인덱스된 컬럼 값 자체를 변환하지 않고 사용해야함**

```sql
SELECT * FROM SALARIES WHERE SALARY * 10 > 150000;
```

위와 같은 쿼리는 컬럼을 가공 후 상수와 비교했기 때문에 인덱스를 이용하지 못함

```SQL
SELECT * FROM SALARIES WHERE SALARY > 150000 / 10;
```

이렇게 작성해서 인덱스를 이용하돌고 유도할 수 있지만  MySQL 옵티마이저는 인덱스를 최저긍로 이용할 수 있게 표현식을 변환하지 못함

복합한 연산을 수행하거나 MD%() 같은 함수와 같이 해시 값을 만들어 비교해야되는 경우라면<br>
미리 계산된 값을 저장하도록 MySQL의 가상컬럼을 추가하고 그 컬럼에 인덱스를 생성하거나 함수기반 인덱스를 사용하면 됨

<br>

**where 절에 사용되는 비교 조건에서 연산자 양쪽의 비교 대상 값의 데이터 타입이 일치해야함**

```sql
CREATE TABLE TB_TEST(AGE VARCHAR(10), INDEX IX_AGE (AGE));
INSERT INTO TB_TEST VALUES ('1'),('2'),('3'),('4'),('5'),('6'),('7');

SELECT * FROM TB_TEST WHERE AGE = 2;
```

위와 같은 경우에 실행계획을 보면 type이 index(인덱스 풀스캔) 인걸 확인 할 수 있음

비교되는 값의 타입이 문자열과 숫자 타입으로 다를 경우 옵티마이저가 문자열 타입을 숫자로 변환후 비교작업을 처리함<br>
=> 인덱스 레인지 스캔이 불가능

### 11.4.2.2 WHERE 절의 인덱스 사용

**작업 범위 결정 조건, 체크조건**

조건들이 인덱스 구성 좌측부터 비교했을때 얼마나 일치하는지에 달렸음

WHERE 절에서 컬럼을 어떤 순서대로 사용하든 옵티마이저가 인덱스를 사용할 수 있는 순서대로 최적화를 시키나<br>
인덱스 컬럼 구성중 중간에 있는 컬럼을 범위비교조건(>, < ...)으로 사용할 시 <br>
범위비교조건을 건 컬럼까지는 작업 범위 결정 조건으로 들어가나 그 뒤로는 체크조건으로 사용됨

> MySQL 8.0 부터 인덱스 구성 시 컬럼에 정순, 역순을 지정할 수 있음<br>
> ``ALTER TABLE ... ADD INDEX IX_COL1234(COL_1 ASC, AOL_2 DESC, COL_3 ASC, COL_4 ASC)``

다음처럼 AND 가 아닌 OR 연산자가 있으면 처리 방법이 완전히 바뀜

```SQL
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME = 'Kebin' OR LAST_NAME = 'Poly';
```

이럴 경우 인덱스가 있는 FIRST_NAME은 인덱스를 사용해서 가져올 수 있지만 LAST_NAME 은 풀스캔으로 가져와야함<br>
스캔을 2번 하는 것보다 풀스캔 1번 하는것이 더 빠르기 때문에 풀스캔으로 실행하게 됨

### 11.4.2.3 GROUP BY 절의 인덱스

GROUP BY 에서 명시된 컬럼의 순서가 인덱스의 구성과 같으면 인덱스를 이용

GROUP BY에 명시된 컬럼 중에 인덱스 구성에 없는 컬럼이 있다면 인덱스 사용 못함
> 인덱스 구성이 COL1, COL2 COL3 일때<br>
> GROUP BY COL1, COL2, COL3, COL4 형식인 경우

WHERE 절에 COL1, COL2 가 동등비교로 사용이 되었을 경우
GROUP BY 에서 COL3만 써도 인덱스가 적용되긴 함

### 11.4.2.4 ORDER BY 절의 인덱스 사용

GROUP BY 절과 사용 조건은 같고 추가적으로 정렬되는 컬럼의 오름차순, 내림차순 옵션이 인덱스와 같거나 정반대여야함

### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 사용

WHERE 절은 A 인덱스를, ORDER BY는 B 인덱스를 사용하도록할 수는 없음

**사용 가능한 경우**
1. WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용할 때<br>
	이 방법이 다른 2가지 보다 더 빨라서 이방법을 사용하도록 튜닝 또는 인덱스를 생성하는 것이 좋음
2. WHERE 절만 인덱스를 이용할 때<br>
  where 절의 조건이 일치하는 레코드가 적을 때 효율적
3. ORDER BY 만 인덱스를 이용할 때<br>
	주로 많은 레코드를 조회해서 정렬해야 할 때 이런 형태로 튜닝

```sql
-- INDEX 가 COL_1, COL_2, COL_3, COL_4 로 구성이 되어있다는 전제
-- 1의 경우

SELECT * FROM TB_TEST
WHERE COL_1 = 10
ORDER BY COL_2, COL_3;

SELECT * FROM TB_TEST
WHERE COL_1 = 10
ORDER BY COL_1, COL_2, COL_3;
```

첫번째 쿼리형태를 보고 두번재 쿼리처럼 형태를 변경해보면  인덱스를 사용하는 지 확실히 알 수 있음

```SQL
SELECT * FROM TB_TEST WHERE COL_1 > 10 ORDER BY COL_1, COL_2, COL_3;
-- ORDER BY 절과 WHERE 절 모두 인덱스 사용 가능

SELECT * FROM TB_TEST WHERE COL_1 > 10 ORDER BY COL_2, COL_3;
-- WHERE 절은 인덱스를 사용 할 수도 있으나 ORDER BY 절은 인덱스를 사용할 수 없음
```

### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY 절과 ORDER BY 절에 명시된 컬럼과 순서가 같아야함

둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘다 인덱스를 사용하지 못함

MySQL 5.7 까지는 GROUP BY 를 수행 시 컬럼에 대한 정렬까지 수행했는데<br>
8.0 부터는  GROUP BY 절이 정렬까지는 보장하지 않는 형태로 바뀌어서 <br>
정렬까지 하려면 ORDER BY 절도 명시해야함

### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용

WHERE, GROUP BY, ORDER BY 절 모두에서 하나의 인덱스를 사용 가능해야함

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/f053d6aa-720b-4555-907a-83bb6ef022a4)

<br>

## 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항

비교조건의 표션식이 상당히 중요

### 11.4.3 NULL 비교

다른 DBMS 와는 다른 MySQL은 NULL 값이 포함된 레코드도 인덱스로 관리됨

SQL 표준에서 NULL의 정의는 비교할 수 없는 값이다.<br>
그래서 두 값이 모두 NULL을 가진다고 하더라고 이 두값이 동등한지 비교하는 것은 불가능하다.<br>
=> 연산이나 비교에서 한쪽이라도 NNULL이면 결과도 NULL이 반환되는 이유

쿼리에서 NULL인지 비교하려면 IS NULL 또는 \<=\> 연산자를 이용, 이외의 방법은 없음

**NULL 비교 예시**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/4a033d28-e0d6-4af9-9b25-d286a2f0c041)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/4aa6711f-ac08-42a8-8a23-92add7a2a258)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/ae8eab55-3b91-42f6-95a7-ddd52dfa527d)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/33553b95-9012-42fc-9dd0-e9545321d7e7)

<br>

**인덱스 사용 예시**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/50393976-2966-4d19-a674-c770b75f3bd4)

인덱스가 잘 사용되는걸 볼 수 있음

**ISNULL() 함수**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/36c19337-ee96-43ec-8343-f8317ddf9b21)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/d4e36118-3ee9-4be5-bebb-e471c08fc004)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/a2ac76db-1d2c-439a-a428-5800016987d5)


### 11.4.3.2 문자열이나 숫자 비교

문자열 컬럼이나 숫자 커럶을 비교할 때는 반드시 그 타입에 맞는 상수값 사용을 권장

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/ee5ffd00-4391-4174-86b8-73ff58b27c73)

### 11.4.3.3 날짜 비교

#### 11.4.3.3.1 DATE 또는 DATETIME과 문자열 비교

DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입 값으로 변화해서 비교함

```SQL
SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > STR_TO_DATE('2011-07-23', '%Y-%m-%d');

-- 위와 아래 쿼리는 똑같이 작동됨(인덱스 사용)

SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > '2011-07-23';
```

```SQL
-- 컬럼 값을 변경하여 비교하기 때문에 인덱스 사용 못함함
SELECT COUNT(*) FROM EMPLOYEES
WHERE DATE_FORMAT(HIRE_DATE, '%Y-%m-%d') > '2011-07-23';
```

#### 11.4.3.2 DATE 와 DATETIME의 비교

DATETIME 값에서 시간만 때버리고 비교하려면 DATE() 함수를 사용하면 됨
```SQL
SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > DATE(NOW());
```

DATE 와 DATETIME 비교 시 DATE 타입의 값을 DATETIME 으로 변경해서 비교하게됨

이 두 타입의 비교에서의 변환은 인덱스 사용여부에 영향을 미치지 않으니 쿼리 결과에 주의해야함

```SQL
SELECT STR_TO_DATE('2011-06-30', '%Y-%m-%d') < STR_TO_DATE('2011-06-30 00:00:01', '%Y-%m-%d %H:%i:%s');

SELECT STR_TO_DATE('2011-06-30', '%Y-%m-%d') >= STR_TO_DATE('2011-06-30 00:00:01', '%Y-%m-%d %H:%i:%s');
```

#### 11.4.3.3.3 DATETIME 과 TIMESTAMP의 비교

DATE, DATETIME 타입의 값과 TIMESTAMP의 값을 타입 변환 없이 비교하면 문제없이 작동하고 인덱스도 사용하는것 처럼 보이지만 사실은 아님

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/44e95097-29ca-4b52-b1bb-0a9ffa1262bb)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/e0dab233-51ac-492c-a1dc-c409b28c4bab)

UNIX_TIMESTAMP()  함수 결과값은 MySQL 내부적으로는 단순 숫자 값임

컬럼이 DATETIME 이면 FROM_UNIXTIME() 을 이용해 TIEMSTAMP 를 DATETIME 으로 변경

컬럼이 TIMESTAMP면 UNIX_TIMESTAMP() 를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/95650d7c-aa1f-474a-912b-a82445198e80)


#### 11.4.3.4 Short-Circuit Evaluation

Short-Circuit Evaluation : 여러 논리 연산자로 연결된 표현식의 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화


<br>

## 11.4.4 DISTINCT

<br>

## 11.4.5 LIMIT n

<br>

## 11.4.6 COUNT()

<br>

## 11.4.7 JOIN

<br>

## 11.4.8 GROUP BY

<br>

## 11.4.9 ORDER BY

<br>

## 11.4.10 서브쿼리
