# 11.4 SELECT

INSERT 나 UPDATE 같은 작업보다 SELECT를 많이 쓰이고 빠르게 동작해야 하니 성능 위주로 보자

## 11.4.1 SELECT 절의 처리 순서

```SQL
SELECT s.emp_no, COUNT(DISTINCT e.first_name) AS cnt
FROM salaries s
	INNER JOIN employees e ON e.emp_no = s.emp_no
WHERE s.emp_no in (100001, 100002)
GROUP BY s.emp_no
HAVING AVG(s.salary) > 1000
ORDER BY AVG(s.salary)
LIMIT 10;
```

쿼리에서 어느절이 먼저 실행될 지 예측하지 못하면 처리내용이나 처리결과를 예측할 수 없음

**테이블 드라이빙(WHERE, JOIN) => GROUP BY => DISTINCT => HAVING => ORDER BY => LIMIT**

ORDER BY나 GROUP BY 절이 있더라도 인덱스를 이용할 때는 그 단계가 불필요해서 생략

<br>

**예외적으로 ORDER BY가 조인보다 먼저 실행되는 경우**

GROUP BY 없이 ORDER BY만 사용된 쿼리<br>
테이블 드라이빙 => ORDER BY => 드리븐 테이블 조인 => LIMIT

<br>

위에서 제시한 2가지의 순서를 벗어나려면 서브쿼리를 사용해야함

```SQL
SELECT EMP_NO, CNT
FROM (
	SELECT S.EMP_NO, COUNT(DISTINCT E.FIRST_NAME) AS CNT, MAX(S.SALARY) AS MAX_SALARY
    FROM SALARIES S
    INNER JOIN EMPLOYEES E ON E.EMP_NO = S.EMP_NO
    WHERE S.EMP_NO IN (100001, 100002)
    GROUP BY S.EMP_NO
    HAVING MAX(S.SALARY) > 1000
    LIMIT 10
) temp_view
ORDER  BY MAX_SALARY;
```

인라인 뷰를 사용하면 임시 테이블이 사용되기 때문에 주의해야함

> MySQL 8.0 부터는 FROM 절의 서브쿼리를 외부 쿼리와 병합해서 쿼리를 최적화 할 수도 있음<br>
> 이 경우 결국 조인으로 실행되는 형태가 되기 때문에 위에서 제시한 1, 2번째 중 하나의 순서로 실행됨


MySQL 8.0에 새로 도입된 WITH절(CTE, Common Table Expression)은 항상 먼저 실행되어 임시테이블로 저장됨

<br>

## 11.4.2 WHERE 절과 GROUP BY 절, ORDER BY 절의 인덱스

### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙

**인덱스된 컬럼 값 자체를 변환하지 않고 사용해야함**

```sql
SELECT * FROM SALARIES WHERE SALARY * 10 > 150000;
```

위와 같은 쿼리는 컬럼을 가공 후 상수와 비교했기 때문에 인덱스를 이용하지 못함

```SQL
SELECT * FROM SALARIES WHERE SALARY > 150000 / 10;
```

이렇게 작성해서 인덱스를 이용하돌고 유도할 수 있지만  MySQL 옵티마이저는 인덱스를 최저긍로 이용할 수 있게 표현식을 변환하지 못함

복합한 연산을 수행하거나 MD%() 같은 함수와 같이 해시 값을 만들어 비교해야되는 경우라면<br>
미리 계산된 값을 저장하도록 MySQL의 가상컬럼을 추가하고 그 컬럼에 인덱스를 생성하거나 함수기반 인덱스를 사용하면 됨

<br>

**where 절에 사용되는 비교 조건에서 연산자 양쪽의 비교 대상 값의 데이터 타입이 일치해야함**

```sql
CREATE TABLE TB_TEST(AGE VARCHAR(10), INDEX IX_AGE (AGE));
INSERT INTO TB_TEST VALUES ('1'),('2'),('3'),('4'),('5'),('6'),('7');

SELECT * FROM TB_TEST WHERE AGE = 2;
```

위와 같은 경우에 실행계획을 보면 type이 index(인덱스 풀스캔) 인걸 확인 할 수 있음

비교되는 값의 타입이 문자열과 숫자 타입으로 다를 경우 옵티마이저가 문자열 타입을 숫자로 변환후 비교작업을 처리함<br>
=> 인덱스 레인지 스캔이 불가능

### 11.4.2.2 WHERE 절의 인덱스 사용

**작업 범위 결정 조건, 체크조건**

조건들이 인덱스 구성 좌측부터 비교했을때 얼마나 일치하는지에 달렸음

WHERE 절에서 컬럼을 어떤 순서대로 사용하든 옵티마이저가 인덱스를 사용할 수 있는 순서대로 최적화를 시키나<br>
인덱스 컬럼 구성중 중간에 있는 컬럼을 범위비교조건(>, < ...)으로 사용할 시 <br>
범위비교조건을 건 컬럼까지는 작업 범위 결정 조건으로 들어가나 그 뒤로는 체크조건으로 사용됨

> MySQL 8.0 부터 인덱스 구성 시 컬럼에 정순, 역순을 지정할 수 있음<br>
> ``ALTER TABLE ... ADD INDEX IX_COL1234(COL_1 ASC, AOL_2 DESC, COL_3 ASC, COL_4 ASC)``

다음처럼 AND 가 아닌 OR 연산자가 있으면 처리 방법이 완전히 바뀜

```SQL
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME = 'Kebin' OR LAST_NAME = 'Poly';
```

이럴 경우 인덱스가 있는 FIRST_NAME은 인덱스를 사용해서 가져올 수 있지만 LAST_NAME 은 풀스캔으로 가져와야함<br>
스캔을 2번 하는 것보다 풀스캔 1번 하는것이 더 빠르기 때문에 풀스캔으로 실행하게 됨

### 11.4.2.3 GROUP BY 절의 인덱스

GROUP BY 에서 명시된 컬럼의 순서가 인덱스의 구성과 같으면 인덱스를 이용

GROUP BY에 명시된 컬럼 중에 인덱스 구성에 없는 컬럼이 있다면 인덱스 사용 못함
> 인덱스 구성이 COL1, COL2 COL3 일때<br>
> GROUP BY COL1, COL2, COL3, COL4 형식인 경우

WHERE 절에 COL1, COL2 가 동등비교로 사용이 되었을 경우
GROUP BY 에서 COL3만 써도 인덱스가 적용되긴 함

### 11.4.2.4 ORDER BY 절의 인덱스 사용

GROUP BY 절과 사용 조건은 같고 추가적으로 정렬되는 컬럼의 오름차순, 내림차순 옵션이 인덱스와 같거나 정반대여야함

### 11.4.2.5 WHERE 조건과 ORDER BY(또는 GROUP BY)절의 인덱스 사용

WHERE 절은 A 인덱스를, ORDER BY는 B 인덱스를 사용하도록할 수는 없음

**사용 가능한 경우**
1. WHERE 절과 ORDER BY 절이 동시에 같은 인덱스를 이용할 때<br>
	이 방법이 다른 2가지 보다 더 빨라서 이방법을 사용하도록 튜닝 또는 인덱스를 생성하는 것이 좋음
2. WHERE 절만 인덱스를 이용할 때<br>
  where 절의 조건이 일치하는 레코드가 적을 때 효율적
3. ORDER BY 만 인덱스를 이용할 때<br>
	주로 많은 레코드를 조회해서 정렬해야 할 때 이런 형태로 튜닝

```sql
-- INDEX 가 COL_1, COL_2, COL_3, COL_4 로 구성이 되어있다는 전제
-- 1의 경우

SELECT * FROM TB_TEST
WHERE COL_1 = 10
ORDER BY COL_2, COL_3;

SELECT * FROM TB_TEST
WHERE COL_1 = 10
ORDER BY COL_1, COL_2, COL_3;
```

첫번째 쿼리형태를 보고 두번재 쿼리처럼 형태를 변경해보면  인덱스를 사용하는 지 확실히 알 수 있음

```SQL
SELECT * FROM TB_TEST WHERE COL_1 > 10 ORDER BY COL_1, COL_2, COL_3;
-- ORDER BY 절과 WHERE 절 모두 인덱스 사용 가능

SELECT * FROM TB_TEST WHERE COL_1 > 10 ORDER BY COL_2, COL_3;
-- WHERE 절은 인덱스를 사용 할 수도 있으나 ORDER BY 절은 인덱스를 사용할 수 없음
```

### 11.4.2.6 GROUP BY 절과 ORDER BY 절의 인덱스 사용

GROUP BY 절과 ORDER BY 절에 명시된 컬럼과 순서가 같아야함

둘 중 하나라도 인덱스를 이용할 수 없을 때는 둘다 인덱스를 사용하지 못함

MySQL 5.7 까지는 GROUP BY 를 수행 시 컬럼에 대한 정렬까지 수행했는데<br>
8.0 부터는  GROUP BY 절이 정렬까지는 보장하지 않는 형태로 바뀌어서 <br>
정렬까지 하려면 ORDER BY 절도 명시해야함

### 11.4.2.7 WHERE 조건과 ORDER BY 절, GROUP BY 절의 인덱스 사용

WHERE, GROUP BY, ORDER BY 절 모두에서 하나의 인덱스를 사용 가능해야함

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/f053d6aa-720b-4555-907a-83bb6ef022a4)

<br>

## 11.4.3 WHERE 절의 비교 조건 사용 시 주의사항

비교조건의 표션식이 상당히 중요

### 11.4.3 NULL 비교

다른 DBMS 와는 다른 MySQL은 NULL 값이 포함된 레코드도 인덱스로 관리됨

SQL 표준에서 NULL의 정의는 비교할 수 없는 값이다.<br>
그래서 두 값이 모두 NULL을 가진다고 하더라고 이 두값이 동등한지 비교하는 것은 불가능하다.<br>
=> 연산이나 비교에서 한쪽이라도 NNULL이면 결과도 NULL이 반환되는 이유

쿼리에서 NULL인지 비교하려면 IS NULL 또는 \<=\> 연산자를 이용, 이외의 방법은 없음

**NULL 비교 예시**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/4a033d28-e0d6-4af9-9b25-d286a2f0c041)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/4aa6711f-ac08-42a8-8a23-92add7a2a258)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/ae8eab55-3b91-42f6-95a7-ddd52dfa527d)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/33553b95-9012-42fc-9dd0-e9545321d7e7)

<br>

**인덱스 사용 예시**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/50393976-2966-4d19-a674-c770b75f3bd4)

인덱스가 잘 사용되는걸 볼 수 있음

**ISNULL() 함수**<br>
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/36c19337-ee96-43ec-8343-f8317ddf9b21)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/d4e36118-3ee9-4be5-bebb-e471c08fc004)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/a2ac76db-1d2c-439a-a428-5800016987d5)


### 11.4.3.2 문자열이나 숫자 비교

문자열 컬럼이나 숫자 커럶을 비교할 때는 반드시 그 타입에 맞는 상수값 사용을 권장

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/ee5ffd00-4391-4174-86b8-73ff58b27c73)

### 11.4.3.3 날짜 비교

#### 11.4.3.3.1 DATE 또는 DATETIME과 문자열 비교

DATE 또는 DATETIME 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 DATETIME 타입 값으로 변화해서 비교함

```SQL
SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > STR_TO_DATE('2011-07-23', '%Y-%m-%d');

-- 위와 아래 쿼리는 똑같이 작동됨(인덱스 사용)

SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > '2011-07-23';
```

```SQL
-- 컬럼 값을 변경하여 비교하기 때문에 인덱스 사용 못함함
SELECT COUNT(*) FROM EMPLOYEES
WHERE DATE_FORMAT(HIRE_DATE, '%Y-%m-%d') > '2011-07-23';
```

#### 11.4.3.2 DATE 와 DATETIME의 비교

DATETIME 값에서 시간만 때버리고 비교하려면 DATE() 함수를 사용하면 됨
```SQL
SELECT COUNT(*) FROM EMPLOYEES
WHERE HIRE_DATE > DATE(NOW());
```

DATE 와 DATETIME 비교 시 DATE 타입의 값을 DATETIME 으로 변경해서 비교하게됨

이 두 타입의 비교에서의 변환은 인덱스 사용여부에 영향을 미치지 않으니 쿼리 결과에 주의해야함

```SQL
SELECT STR_TO_DATE('2011-06-30', '%Y-%m-%d') < STR_TO_DATE('2011-06-30 00:00:01', '%Y-%m-%d %H:%i:%s');

SELECT STR_TO_DATE('2011-06-30', '%Y-%m-%d') >= STR_TO_DATE('2011-06-30 00:00:01', '%Y-%m-%d %H:%i:%s');
```

#### 11.4.3.3.3 DATETIME 과 TIMESTAMP의 비교

DATE, DATETIME 타입의 값과 TIMESTAMP의 값을 타입 변환 없이 비교하면 문제없이 작동하고 인덱스도 사용하는것 처럼 보이지만 사실은 아님

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/44e95097-29ca-4b52-b1bb-0a9ffa1262bb)

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/e0dab233-51ac-492c-a1dc-c409b28c4bab)

UNIX_TIMESTAMP()  함수 결과값은 MySQL 내부적으로는 단순 숫자 값임

컬럼이 DATETIME 이면 FROM_UNIXTIME() 을 이용해 TIEMSTAMP 를 DATETIME 으로 변경

컬럼이 TIMESTAMP면 UNIX_TIMESTAMP() 를 이용해 DATETIME을 TIMESTAMP로 변환해서 비교

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/92290312/95650d7c-aa1f-474a-912b-a82445198e80)


#### 11.4.3.4 Short-Circuit Evaluation

Short-Circuit Evaluation : 여러 논리 연산자로 연결된 표현식의 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화

WHERE 절의 조건 순서에 따라서도 쿼리의 성능이 달라질 수 있음

```SQL
SELECT * FROM SALARIES
WHERE CONVERT_TZ(FROM_dATE, '+00:00', '+09:00') > '1991-01-01'
AND TO_DATE < '1985-01-01'
-- CONVERT_TZ 를 먼저 실행 후 비교 -> TO_DATE 비교
-- 만약 TO_DATE 비교하는 부분이 더 데이터를 많이 걸러낸다면
-- CONVERT_TZ를 불필요하게 더 많이 실행하는 것이니 순서를 바꾸는 것이 효율적임
```

WHERE 절에 인덱스를 사용한다면 Short-Circuit Evaluation 과 상관 없이 인덱스가 최우선

```sql
SELECT * FROM EMPLOYEES
WHERE LAST_NAE = 'Aamodt'
  AND FIRST_NAME = 'Matt';
-- FIRST_NAME 이 인덱스 컬럼이니 FIRST_NAME 부터 인덱스 탐색 후 LAST_NAME 비교
```

```SQL
FLUSH STATUS;
 SELECT * FROM EXMPLOYEES E
WHERE E.FIRST_NAME = 'Matt'
  AND E.LAST_NAME = 'Aamodt'
  AND EXISTS (SELECT 1 FROM SALARIES S
		WHERE S.EMP_NO = E.EMP_NO AND S.TO_DATE > '1995-01-01'
		GROUP BY S.SALARY HAVING COUNT(1) > 1);
SHOW STATUS LIKE 'Handler%';

FLUSH STATUS;
 SELECT * FROM EXMPLOYEES E
WHERE E.FIRST_NAME = 'Matt'
  AND EXISTS (SELECT 1 FROM SALARIES S
		WHERE S.EMP_NO = E.EMP_NO AND S.TO_DATE > '1995-01-01'
		GROUP BY S.SALARY HAVING COUNT(1) > 1)
  AND E.LAST_NAME = 'Aamodt';
SHOW STATUS LIKE 'Handler%';
```

쿼리 작성 시 가능하면 복잡한 연산 또는 서브쿼리 등은 where 절의 뒤쪽으로 배치하는 것이 성능상 도움이 됨

<br>

## 11.4.4 DISTINCT

DISTINCT 를 남용하면 성능상 문제도 있고 쿼리 결과도 달라질 수 있음
> 테이블 간 조인 시 1:1 인지 1:N 인지 엄부적인 특성을 잘 이해해야함

<br>

## 11.4.5 LIMIT n

```SQL
SELECT * FROM EMPLOYEES
WHERE EMP_NO BETWEEN 10001 AND 10010
ORDER BY FIRST_NAME
LIMIT 0, 5;
```

LIMIT 은 WHERE 조건이 아니기 때문에 항상 쿼리의 마짐낙에 실행됨.<br>
필요한 레코드 건수만 준비되면 쿼리가 종료됨 => 상위 5개만 정렬되면 종료됨

```SQL
SELECT * FROM EMPLOYEES LIMIT 0, 10;
-- 풀테이블 스캔을 실행하면서 스토리지 엔진으로 부터 10개의 레코드를 읽어 들이는 순간 읽기 멈춤

SELECT FIRST_NAME FROM EMPLOYEES GROUP BY FIRST_NAME LIMIT 0, 10;
-- GROUP BY 후 LIMIT 이 실행되기 때문에 실질적으로 작업 내용을 크게 줄여주지 못함

SELECT DISTINCT FIRST_NAME FROM EMPLOYEES LIMIT 0, 10;
-- 풀테이블 스캔을 이용해 데이터를 읽음과 동시에 중복 제거 작업(임시 테이블 이용)을 진행
-- 유니크한 레코드가 LIMIT 건수만큼 채워지면 쿼리 종료

SELECT * FROM EMPLOYEES
WHERE EMP_NO BETWEEN 10001 AND 11000
ORDER BY FIRST_NAME
LIMIT 0, 10;
-- WHERE 절을 만족하는 데이터를 불러오고 FIRST_NAME 으로 정렬하는 도중 10건이 만족되면 쿼리 종료
```

위처럼 인덱스를 이용할 수 없는 GROUP BY , ORDER BY, DISTINCT 는 LIMIT 이 성능 향상에 크게 도움이 되진 않음

> LIMIT 10 => 상위 10개
> LIMIT 10, 10 => 상위 11번째 부터 10개

실제 쿼리의 결과보다는 MySQL 서버에서 어떤 작업을 하는지 주의 해야함.<br>
만약 LIMIT 200000, 10 이면 총 200010 건을 읽고 난 후 200000 건을 버리게 되어 시간이 오래 걸림

<br>

## 11.4.6 COUNT()

COUNT(*) 에서 *은 모든 컬럼을 의미하는 것이 아닌 레코드 자체를 의미하기 때문에 COUNT(1) 이나 COUNT(PK) 와 동일한 처리 성능을 보임

MyISAM 스토리지 엔진을 사용하는 테이블은 항상 테이블의 메타 정보에 전체 레코드 건수를 관리함<br>
=> where 조건인 없는 count() 쿼리는 빠르게 처리됨

InnoDB 스토리지 엔진을 사용하는 테이블에서는 where 조건이 없더라도 직접 데이터나 인덱스를 읽어야함

> SHOW TABLE STATUS; 명령으로 전체 건수를 확인하는 방법도 있음<br>
> ANALYZE TABLE 명령으로 통계정보를 갱신하면 정확해짐
> ```
> SELECT TABLE_SCHEMA, TABLE_NAME, TABLE_ROWS
> 	(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024/ 1024 AD TABLE_SIZE_GB
> FROM information_schema.TABLES
> WHERE TABLE_SCHEMA = 'employees' AND TABLE_NAME = 'employees';
> ```

count() 시 동작 상 의미 없는 order by 절이나 left join 은 성능을 안좋게 만들 뿐임

count() 도 인덱스를 사용하지 않으면 느려질 수 있음

count() 사용시 컬럼이나 표현식을 넘길때 그 값이 null 이 아닌것만 셈

<br>

## 11.4.7 JOIN

JOIN인 어떻게 인덱스를 사용하는지 패턴별로 알아보자

### 11.4.7.1 JOIN의 순서와 인덱스

조인 작업에서는 드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행하고, 그 이후부터는 스캔만 함.<br>
드리븐 테이블에서는 인덱스 탐색과 스캔 작업이 드라이빙 테이블에서 읽은 레코드 건수만큼 반복.<br>
=> 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립

```SQL
SELECT *
FROM EMPLOYEES E, DEPT_EMP DE
WHERE E.EMP_NO = DE.EMP_NO;

/*
1. 두 컬럼 모두 각각 인덱스가 있는 경우
옵티마이저가 통계 정보를 이용해 드라이빙 테이블을 선택함.
보통 옵티마이저가 선택하는것이 최적임

2. EMPLOYEES 에만 인덱스가 있는 경우
EMPLOYEES 테이블을 드라이빙 테이블로 선택하면 DEPT_EMP 를 매번 풀스캔 해야함
DEPT_EMP 를 드라이빙으로 선택하면 EMPLOYEES 에 접근시 인덱스를 사용가능함
EMPLOYEES 테이블을 하주 효율적으로 접근할 수 있는 조건이 있더라고 DEPT_EMP 를 드라이빙으로 선택할 가능성이 높음

3. 둘다 인덱스가 없는 경우
옵티마이저가 알아서 드라이빙 테이블을 선택하지만 레코드 수가 적은 테이블을 드라이빙 테이블로 선택하는 것이 효율적임
MySQL 8.0.18 전까지는 블록 네스티드 루프를 사용했지만
MySQL 8.0.18 부터 블록네스티드 루프 조인이 없어지고 해시 조인이 도입되면서 해시 조인으로 처리
*/
```

### 11.4.7.2 JOIN 컬럼의 데이터 타입

WHERE 절의 인덱스 사용시 데이터 타입 조건처럼 JOIN 에서도 동일하다.

```SQL
CREATE TABLE TB_TEST1(USER_ID INT, USER_TYPE INT, PRIMARY KEY (USER_ID));
CREATE TABLE TB_TEST2(USER_TYPE CHAR(1), TYPE_DESC VARCHAR(10), PRIMARY KEY(USER_TYPE));

SELECT *
FROM TB_TEST1 TB1, TB_TEST2 TB2
WHERE TB1.USER_TYPE = TB2.USER_TYPE;

-- 이 경우 두 테이블 모두 풀테이블 스캔으로 접근
-- 드리븐 테이블이 풀스캔되면서 조금이라도 빨리 실행되도록 조인 버퍼를 활용한 해시 조인을 사용
```

대표적으로 문제 되는 비교패턴
+ CHAR, INT 처럼 데이터 타입의 종류가 완전히 다른경우
+ 같은 CHAR 타입이더라도 문자 집합이나 콜렉이션이 다른 경우
+ 같은 INT 라도 부호의 존재 여부(SIGN)가 다른경우

### 11.4.7.3 OUTER JOIN 의 성능과 주의사항

```SQL
SEELCT *
FROM EMPLOYEES E
LEFT JOIN DEPT_EMP DE
	ON DE.EMP_NO = E.EMP_NO
LEFT JOIN DEPARTMENTS D
	ON D.DEPT_NO = DE.DEPT_NO
	AND D.DEMP_NAME = 'Development';


SEELCT *
FROM EMPLOYEES E
JOIN DEPT_EMP DE
	ON DE.EMP_NO = E.EMP_NO
JOIN DEPARTMENTS D
	ON D.DEPT_NO = DE.DEPT_NO
	AND D.DEMP_NAME = 'Development';
```

아우터로 조인되는 테이블은 드라이빙 테이블로 선택하지 못함

조인 조건으로 사용하는 컬럼을 where 절에 같이 명시하는 건 잘못된 조인 방법임

```sql
SELECT *
FROM EMPLOYYES E
LEFT JOIN DEPT_MANAGER MGR
	ON MGR.EMP_NO = E.EMP_NO
WHERE MGR.DEPT_NO = 'd001';

-- where 조건 때문에 옵티마이저가 inner로 변경해서 실행함
-- 정상적인 아우터 조인을 하려면 on 절에 조건을 추가해야함

-- 안티조인의 효과를 기대하는 경우는 where 절에 조건을 붙이는건 괜춘
-- 예) where demp_no is null
```





<br>

## 11.4.8 GROUP BY

<br>

## 11.4.9 ORDER BY

<br>

## 11.4.10 서브쿼리
