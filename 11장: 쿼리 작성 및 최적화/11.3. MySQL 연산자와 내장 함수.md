# MySQL 연산자와 내장 함수
MYSQL에서만 사용 가능한 연산자도 있지만, 가능하다면 SQL의 가독성을 높이기 위해 ANSI 표준 형태의 연산자를 사용하길 권장한다.  
일반적으로 각 DBMS의 내장 함수는 거의 같은 기능을 제공하지만, 이름이 호환되는 것은 거의 없다.  
(너무 기본적인 내용은 제외할게요...)  

## 리터럴 표기법 문자열
### 문자열
SQL 표준에서 문자열은 항상 홑따옴표(')를 사용해서 표시한다.  
그러나 MYSQL에서는 다음과 같이 쌍따옴표를 사용해 문자열을 표기할 수 있다.  

### 날짜
다른 DBMS에서 날짜 타입을 비교하거나 INSERT하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하다.  
하지만 MYSQL에서는 정해진 형태의 날짜 포맷으로 표기하면 자동으로 DATE나 DATETIME값으로 변환한다.  

### 불리언
BOOL이나 BOOLEAN이라는 타입이 있지만 TRUE는 1, FALSE는 0로 조회된다.  
이는 애플리케이션의 버그로 연결됐을 가능성이 있기 때문에 BOOL 타입을 사용하고 싶다면 ENUM 타입으로 관리하는 것이 조금 더 명확하고 실수를 줄일 수 있는 방법.  

## MYSQL 연산자
### 동등(Equal) 비교
다른 DBMS와 마찬가지로 '='연산자를 사용해 비교를 수행한다.  
그러나 MYSQL에서는 '<=>' 연산자도 제공한다.  
이는 =과 같으며부가적으로 NULL값에 대한 비교까지 수행한다.  
NULL-SAFE 비교 연산자라고 함.  

### 부정 비교(<>, !=)
둘중 뭘 사용해도 상관없지만 통일해서 사용하자.  

### NOT 연산자(!)
부정 연산자  

### AND(&&)와 OR(||) 연산자
AND와 OR뿐만 아니라 &&, ||도 허용한다.  
오라클에서는 ||가 결합연산자였지만 MYSQL에서는 OR연산자.  
그러나 가독성을 높이기 위해 AND, OR을 사용하자.  

### 나누기(/, DIV)와 나머지(%, MOD) 연산자

### REGEXP 연산자
문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자.  
RLIKE는 REGEXP와 똑같은 비교를 수행한다.  
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/7dca6320-2e8b-41f9-a867-81c246d47b3a)  

`정규식`  
* ^ : 문자열의 시작을 표시, '^'를 표현식의 앞쪽에 넣어주면 일치하는 부분이 반드시 문자열의 제일 앞쪽에 있어야함.
* $ : 문자열의 끝을 표시, ^와는 반대로 표현식의 끝부분에 $가 있다면 일치하는 부분이 바늗시 문자열의 제일 끝
* [] : 문자 그룹을 표시, [xyz] 또는 [x-z]라고 표현하면 x,y,z 문자 중 하나인지 확인. 대괄호는 문자 하나와 일치하는지를 확인하는 것
* () : 문자열 그룹을 표시, (xyz)라고 한다면 반드시 'xyz'가 모두 있는지 확인
* | : '|'로 연결된 문자열 중 하나인지 확인. "abc|xyz"라고 표현한다면 "abc"이거나 "xyz"인지 확인
* . : 어떠한 문자든지 1개의 문자를 표시, "..."라고 표현하면 어떤문자든지 3개의 문자로 구성된 문자열을 찾는 것
* '*' : 이 기호 앞에 표시된 정규 표현식이 0번 또는 1번 이상 반복될 수 있다는 표시
* '+' : 이 기호 앞에 표시된 정규 표현식이 1번 이상 반복될 수 있다는 표시
* '?' : 이 기호 앞에 표시된 정규 표현식이 0번 또는 1번만 올 수 있다는 표시

```
[0-9]* : 0~9까지의 숫자만 0 또는 1번 이상 반복되는 문자열을 위한 정규 표현
^Tear : Tear문자열로 시작하는 정규 표현
Tear$ : Tear문자열로 끝나는 정규 표현
^Tear& : Tear와 같은 문자열에 대한 정규 표현. T로 시작하고 연속해서 ear이 나타나야하며 그 뒤에 아무런 문자가 없어야 함.  
```

### LIKE 연산자
LIKE에서 사용할 수 있는 와일드 카드는 '%'와 '_'가 전부.  

### BETWEEN 연산자
'>=', '<=' 두 개의 연산자를 하나로 합친 연산자
BETWEEN는 다른 비교 조건과 결합해 하나의 인덱스를 사용할 떄 주의해야한다.  
```
SELECT * FROM dept_emp
WHERE dept_no BETWEEN 'd003' AND 'd005' AND emp_no=10001;

SELECT * FROM dept_emp
WHERE dept_no IN('d003', 'd004', 'd005')
AND emp_no=10001
```  

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/7315cd1f-62ae-43c5-99bd-b9af31f176fd)  

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/71be4569-946e-4b09-8590-c74a1831621a)  

![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/ae57dcb2-3f61-4131-b519-1e0b6cb91d13)  

둘다 range index scan을 하고 있지만 rows 칼럼에 표시된 레코드 건수는 매우 큰 차이가 있다.  



### IN 연산자
BETWEEN은 범위로 검색하지만 IN은 여러번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 처리된다.  
IN 연산자는 두 형태를 구분해서 생각해 볼 수있다.

* 상수가 사용된 경우 IN (?, ?, ?)
* 서브 쿼리가 사용된 경우 IN (SELECT .. FROM .. )

상수가 사용된 경우는 동등 비교와 동일하게 작동하기 때문에 매우 빠르게 쿼리가 처리된다.  
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/762194df-bef1-4ff1-a54b-24afb03c8481)  

MYSQL 8.0 이전 까지는 IN 절에 튜플을 사용하면 풀 테이블 스캔을 해서 일부러 쿼리를 쪼개어 여러 번 실행했다.  
그러나 8.0 버전부터는 위 쿼리와 같이 인덱스를 최적으로 사용할 수 있게 개선됐다.  

`NOT IN` 의 실행계획은 인덱스 풀 스캔으로 표시된다.  
동등이 아닌 부정형 비교라서 인덱스를 이용해 처리 범위를 줄이는 조건으로 사용할 수 없기 떄문이다.  


## MYSQL 내장 함수
DBMS 종류와 관계없이 기본적인 기능의 SQL함수는 대부분 동일하게 제공되지만 함수의 이름이나 사용법이 표준이 없음으로 DBMS별로 거의 호환되지 않는다.  
MYSQL의 함수는 기본으로 제공되는 내장 함수와 직접 작성해서 추가할 수 있는 사용자 정의 함수로 구분된다.  
사용자 정의 함수는 C/C++ API를 이용하여 원하는 기능을 직접 함수로 만들어 추가할 수 있다.(프로시저나 스토어드 함수와는 다름)  

### NULL 처리(IFNULL, ISNULL, CASE, COALESCE)
* IFNULL - 해당 Column의 값이 NULL을 반환할 때, 다른 값으로 출력할 수 있도록 하는 함수
```
SELECT IFNULL(Column명, "Null일 경우 대체 값") FROM 테이블명; 
```

* ISNULL - 인자로 전달한 값이 NULL인지 아닌지 비교하는 함수, NULL이면 TRUE(1) NULL이 아니면 FALSE(0) 으로 반환
```
SELECT ISNULL(0); -> 0
SELECT ISNULL(1/0); ->1
```

* CASE - 해당 Column 값을 조건식을 통해 True, False를 판단하여 조건에 맞게 Column값을 변환할 때 사용하는 함수
```
CASE 
    WHEN 조건식1 THEN 식1
    WHEN 조건식2 THEN 식2
    ...
    ELSE 조건에 맞는경우가 없는 경우 실행할 식
END

// NAME Column의 IS NULL 조건이 True인 경우 "No name" 출력
// WHEN 조건들에 True인 조건이 없을 경우 ELSE 문을 통해 NAME Column의 값 출력
// END 이후 그 Column의 별칭을 NAME으로 지정
SELECT 
    CASE
        WHEN NAME IS NULL THEN "No name"
        ELSE NAME
    END as NAME
FROM ANIMAL_INS
```

* COALESCE - 지정한 표현식들 중에 NULL이 아닌 첫 번째 값을 반환한다. 모든 DBMS에서 사용가능
```
// NULL 처리 상황
SELECT COALESCE(Column명1, Column명1이 NULL인 경우 대체할 값)
FROM 테이블명


// 배타적 OR 관계 열
// Column1 ~ 4 중 NULL이 아닌 첫 번째 Column을 출력
SELECT COALESCE(Column명1, Column명2, Column명3, Column명4)
FROM 테이블명
```








     



