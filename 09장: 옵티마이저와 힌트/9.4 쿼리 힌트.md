# 쿼리 힌트
쿼리의 실행 계획 최적화가 많이 성숙해졌지만, 여전히 MYSQL 서버는 우리가 서비스하는 비즈니스를 100% 이해하지 못한다.  
이런 경우에 옵티마이저에게 쿼리의 실행 계획을 어떻게 수립해야 할 지 알려줄 수 있는 방법이 필요하다.  
MYSQL 서버에서 사용 가능한 쿼리 힌트는 2가지로 구분된다.  
* 인덱스 힌트
* 옵티마이저 힌트

인덱스 힌트는 예전 버전의 MYSQL 서버에서 사용되어 오던 `USE INDEX`같은 힌트를 의미하며,  
옵티마이저 힌트는 5.6 버전부터 새롭게 추가되기 시작한 힌트를 말한다.  

## 인덱스 힌트
`STRIGHT JOIN`과 `USE INDEX`등을 포함한 힌트들은 MYSQL 서버에 옵티마이저 힌트가 도입되기 전에 사용된 기능으로,  
`ANSI-SQL` 표준 문법을 준수하지 못한다.  
MYSQL 5.6 버전부터 추가되기 시작한 옵티마이저 힌트는 MYSQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석되기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다.  
그래서 <b>가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용해라.</b>  
또한 인덱스 힌트는 `SELECT` 명령과 `UPDATE`명령에서만 사용 가능 하다.  

### STRAIGHT_JOIN
STRAIGHT_JOIN은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정한다.  
다음 쿼리는 3개의 테이블을 조인하지만, 어떤 테이블이 드라이빙 테이블이 되고, 드리븐 테이블이 되는지 알 수 없다.  
옵티마이저가 각 테이블의 통계 정보와 쿼리의 조건을 기반으로 가장 최적이라고 판단되는 순서로 조인한다.  
``` 
select count(*) from departments; (9)
select count(*) from dept_emp; (331603)
select count(*) from employees; (300024)
```  
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/d269ca04-8058-4bca-ba93-adc977d73d68)  

위 실행 계획을 확인해보면, departments 테이블을 드라이빙 테이블로 선택하고, 두번쨰로 dept_emp 테이블을 읽은 뒤 employees 테이블을 읽었다.  
일반적으로, 조인을 하기 위한 인덱스 여부로 조인의 순서가 결정되며, 조인 칼럼의 인덱스가 아무런 문제가 없을 경우에는 레코드가 적은 테이블을 드라이빙 테이블로 선택한다.  
<br>
이 쿼리의 조인 순서를 변경하려는 경우에는 `STRAIGHT_JOIN` 힌트를 사용할 수 있다.  
![image](https://github.com/RealMySQL-Study/REAL_MYSQL_STUDY/assets/67637716/3d09a183-24f9-4aec-89a9-d56180a1942a)  
이 쿼리의 실행 계획을 보면 FROM절에 명시한 테이블의 순서대로 조인을 수행한다.  

주로 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 STRAIGHT_JOIN 힌트로 조인 순서를 조정하는 것이 좋다.  
* 임시 테이블(인라인 뷰)과 일반 테이블의 조인 : 거의 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다. 일반 테이블의 조인 칼럼에 인덱스가 없는 경우에는 레코드 건수가 작은 쪽을 먼저 읽도록 드라이빙으로 선택하는 것이 좋은데, 대부분 옵티마이저가 적절한 조인 순서를 선택하기 때문에 쿼리를 작성할 떄부터 힌트를 사용할 필요는 없다. 옵티마이저가 실행 계획을 제대로 수립하지 못해서 심각한 성능 저하가 있을 경우에 힌트를 사용하면 된다.
* 임시 테이블끼리 조인 : 임시테이블은 항상 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무방하기 때문에 크기가 작은 테이블을 드라이빙으로 선택하는 것이 좋다.
* 일반 테이블끼리 조인 : 양쪽 테이블 모두 조인 칼럼에 인덱스가 있거나 둘다 없을 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택하는 것이 좋고, 그 이외라면 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋음.

레코드 건수라는 건 인덱스를 WHERE조건을 만족하는 레코드를 의미하는 것이다.(전체 레코드건수가 아님!)  
STRAIGHT_JOIN 힌트와 비슷한 역할을 하는 옵티마이저 힌트  : 
* JOIN_FIXED_ORDER
* JOIN_ORDER
* JOIN_PREFIX
* JOIN_SUFFIX

### USE INDEX/ FORCE INDEX/ IGNORE INDEX
인덱스 힌트는 사용하려는 인덱스를 가지는 테이블 뒤에 힌트를 명시해야한다.  
대체로 옵티마이저는 어떤 인덱스를 사용해야 할지를 무난하게 잘 선택한다.  
하지만 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하는 경우, 옵티마이저가 실수를 하는데 이런 경우에 강제로 특정 인덱스를 사용하도록 힌트를 줄 수 있다.  
인덱스 힌트는 크게 3종류가 있다.  
* USE INDEX : 가장 자주 사용되는 인덱스 힌트로, 옵티마이저에게 특정 테이블의 인덱스를 사용하도록 권장하는 힌트이다. 옵티마이저는 사용자의 힌트를 채택하지만 그 인덱스를 항상 사용하는 것은 아니다.(?)
* FORCE INDEX : USE INDEX와 비교해 다른점은 없고, USE INDEX보다 옵티마이저에게 미치는 영향이 더 강한 힌트이다. USE INDEX 힌트를 부여했는데도 그 인덱스를 사용하지 않는 경우라면 FORCE INDEX 힌트를 사용해도 그 인덱스를 사용하지 않았다.(??)
* INGNORE INDEX : 특정 인덱스를 사용하지 못하게 하는 용도로 사용한다. 때로는 옵티마이저가 풀 테이블 스캔을 사용하도록 유도하기 위해 IGNORE INDEX 힌트를 사용할 수 있다.

위 3종류의 인덱스 힌트 모두 용도를 명시할 수 있다.  
용도는 선택사항이며, 인덱스 힌트에 용도가 명시되지 않으면 주어진 인덱스를 3가지 용도로 사용한다.  
* USE INDEX FOR JOIN : JOIN이라는 키워드는 테이블 간의 조인 뿐 아니라 레코드를 검색하기 위한 용도까지 포함하는 용아. (하나의 테이블 검색 포함)
* USE INDEX FOR ORDER BY : 명시된 인덱스를 ORDER BY 용도로만 사용할 수 있게 제한.
* USE INDEX FOR GROUP BY : 명시된 인덱스를 GROUP BY 용도로만 사용할 수 있게 제한.

용도는 보통 옵티마이저가 대부분 최적으로 선택하기 때문에 용도까지는 크게 고려하지 않아도 된다.  




